---
title: Introducci칩n a la programaci칩n funcional
date: '2020-07-26'
description: 3 Conceptos claves para iniciar en el mundo de la programaci칩n funcional. En este primer apartado vamos a estar tratando los tres pilares escenciales de la programaci칩n funcional.
author: Misael Taveras
tags: ['JavaScript', 'FP']
status: published
banner: './media/banner-introduccion-a-la-programacion-funcional.jpg'
---

La programaci칩n funcional es un paradigma que me apasiona. No me declaro el mejor, ni un experto, a lo mucho un aficionado; y aunque hace mucho tiempo ya que no me sumerjo como sol칤a hacer, un post (o una serie) de conceptos fundamentales me ayudar칤a a refrescar mi memoria y retomar el buen camino.

<Blockquote type="disclaimer">

El contexto de el post va a estar en JavaScript, que si bien no es un lenguaje puramente funcional su naturaleza nos permite aplicar la mayor칤a de estos patrones, ya sea directamente o a trav칠s de librer칤as.

</Blockquote>

## Programaci칩n funcional

En su definici칩n m치s b치sica, es un paradigma de programaci칩n que utiliza datos **inmutables** para **componer** funciones **puras** evitando los **efectos secundarios**.

Es un poco de vocabulario que procesar, y naturalmente hay m치s de la programaci칩n funcional que solo este pu침ado de elementos, pero creo que son los pilares sobre los que se construyen los dem치s y es por esto que hoy vamos a ver lo que he denominado el ISP (usar칠 vocabulario en ingl칠s en ocasiones porque es como mayormente se encuentra la terminolog칤a).

**Immutability + Side Effects + Purity = ISP**

> _No permitas que las palabras nuevas te intimiden, son m치s f치ciles de lo que suenan._ <br /> Eric Elliot, [Master the JavaScript Interview: What is Functional Programming?]((https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0#e84e))

## 1. Inmutabilidad - Immutability

Un valor inmutable es aquel que no puede cambiar una vez que fue creado.

En JavaScript hay dos tipos de valores, primitivos y objetos. Todos los valores primitivos son inmutables

![./media/immutable-string.png](./media/immutable-string.png "Imagen sin sombra")
<Caption
  align="center"
  footNote="Cambiarle el length a un string manualmente no modifica realmente el valor"
>

Cambiarle el length a un string manualmente no modifica realmente el valor

</Caption>

Los objetos por otro lado no lo son. Recordar que en JavaScript los arrays, las funciones y naturalmente los objetos **todos son objetos en el fondo**. Esto complica ligeramente el trabajar con un paradigma funcional cuando la mayor parte de los valores con los que interactuamos son mutables.

Para ayudar la crisis de inmutabilidad en JavaScript existen unas cuantas librer칤as que permiten tener objetos inmutables a partir de valores mutables. La m치s popular de esta [Immutable.js](https://immutable-js.github.io/immutable-js/) (por Facebook). Otra famosa pero algo desactualizada (desde 2015) es [Mori](https://github.com/swannodette/mori). Si quieres una lista con las librer칤as disponibles [ac치 te dejo un enlace](https://gist.github.com/camsong/33983cdf8371cf9ecdce).

Cabe destacar que aunque JavaScript ha introducido recientemente las `const` esto no indica inmutabilidad como pudimos ver en el ejemplo anterior con el `name`.

JavaScript nos permite crear o trabajar de forma *inmutable* con los objetos sin utilizar ninguna librer칤a utilizando m칠todos como [map, filter, reduce](/blog/usar-map-filter-y-reduce-para-olvidarnos-de-los-bucles-for) en los arrays y [object destructuring](/blog/javascript-todo-lo-nuevo-desde-es6-hasta-hoy-parte-1#destructuring).

### La raz칩n de la inmutabilidad

En la programaci칩n funcional la inmutabilidad es lo que hace que los dem치s conceptos funcionen. Si nuestra data fuera mutable la composici칩n de funciones colapsar칤a y podr칤amos fallar en no tener estado compartidom, que es otro de los pilares de la programaci칩n funcional.

Una de las principales desventajas de la mutabilidad es que nos hace vulnerables a que las funciones que utilizan la data colisionen una con otra.

![./media/mutable-person.png](./media/mutable-person.png "Imagen sin sombra")

<Caption
  align="center"
  footNote="Un ejemplo de que usar `const` no hace que el c칩digo sea inmutable mostrando los peligros de usar estado compartido y valores mutables."
>

Un ejemplo de que usar `const` no hace que el c칩digo sea inmutable mostrando los peligros de usar estado compartido y valores mutables.

</Caption>

En este ejemplo una **CONSTANTE** global `person` se crea con el nombre de 'Raul'. La funci칩n `login` est치 esperando que el nombre de la persona tiene 'Raul', pero justo antes se llam칩 la funci칩n `updateName` que modifica la constante global, por lo que la funci칩n `login` va a fallar y nadie sabr치 porqu칠.

Este ejemplo aunque exagerado y algo tonto, se ve en c칩digo en producci칩n en muchas aplicaciones. Por supuesto que la llamada a `updateName` y `login` puede que no est칠n en el mismo archivo incluso, al usar valores mutables y estado compartido hacemos que ninguna de las dos funciones sepa realmente el da침o que est치 haciendo al resto de la app.

![./media/immutable-person.png](./media/immutable-person.png "Imagen sin sombra")

<Caption
  align="center"
  footNote="El mismo ejemplo anterior pero utilizando Immutable.js"
>

El mismo ejemplo anterior pero utilizando Immutable.js

</Caption>

En este caso aunque la sintaxis es un poco m치s larga podemos ver que no hay forma de que la funci칩n `updateName` mute nuestro objeto immutable de ninguna manera. As칤 que se puede decir que la funci칩n `updateName` (mejorada) no tiene Efectos Secundarios.

## 2. Efectos secundarios - Side Effects

*Nauseas, mareos y dolores de cabeza son algunos efectos secundarios de ciertos medicamentos.* Se puede decir que **un efecto secundario es cualquier cambio observable fuera de la intenci칩n del producto.**

En la programaci칩n funcional **un efecto secundario es cualquier cambio en el estado/comportamiento de la aplicaci칩n observable fuera de la funci칩n en la que se ejecuta.** En algunas ocasiones los efectos secundarios son evidentes y en otros un poco m치s sutiles.

Continuando con nuestro ejemplo anterior (el primero, mutable) en ambas funciones podemos observar efectos secundarios. La funci칩n `updateName` no recibe ning칰n par치metro por lo que modifica el estado global de nuestra aplicaci칩n causando un efecto no deseado en la funci칩n `login`. La funci칩n login por otro lado (en ambos casos) tiene un efecto secundario un poco m치s sutil, en especial cuando estamos iniciando con la programaci칩n funcional, y es que hace `log` en la consola, algo que est치 fuera del alcance de ella.

Una lista de los efectos secundarios m치s comunes es:

* Modificar, crear o eliminar cualquier variable fuera del _scope_ de nuestra funci칩n.
* Mostrar informaci칩n por la consola.
* Escribir o imprimir por pantalla o a alg칰n archivo.
* Hacer una llamada a la red.
* Iniciar o correr procesos externos.
* Hacer llamadas a la base de datos
* Llamar a una funci칩n con efectos secundarios.

Si lo vemos as칤 e intentamos evitar los efectos secundarios como evitamos los valores mutables nuestros programas ser칤an aburridos y solo ser칤an un mont칩n de funciones que se pasaran informaci칩n entre ellas sin que el usuario supiera lo que est치 pasando.

Es por esto que l**os efectos secundarios NO SE ELIMINAN, SE CONTROLAN.** No existe un programa que pueda existir sin efectos secundarios. Nuestro trabajo como desarrolladores est치 en controlar y minimizar estos efectos secundarios.

Una de las t칠cnicas m치s importantes es la de **aplazar los efectos secundarios hasta que sean estrictamente necesarios.** En conjunto con esto podemos mover todos los efectos secundarios a un solo lugar y de ese modo tener m치s control sobre d칩nde y cu치ndo ocurren.

Veamos nuestro c칩digo de arriba con efectos secundarios minimizados (sin necesidad de librer칤as)

![./media/no-side-effects-person.png](./media/no-side-effects-person.png "Imagen sin sombra")

<Caption
  align="center"
  footNote=""
>

Hemos modificado nuestro c칩digo para tener menos side effects dejando solo el necesario de mostrar por consola.

</Caption>

Como podemos observar no solo hemos reducido los efectos secundarios a solo lo necesario y lo hemos movido a su propia funci칩n, sino que "sin querer" hemos implementado inmutabilidad ya que `person` sigue siendo `"Raul"` y `"Maria"` es `newPerson`.

<Blockquote type="info">

No estoy utilizando arrow functions aqu칤 para poder comentar mejor en los snippets, pero en los ejemplos de c칩digo directo si estoy usando arrow function. En este caso las arrow functions y las cl치sicas funcionan igual. Para saber m치s sobre la no tan nueva sintaxis te dejo **[un enlace ac치](/blog/javascript-todo-lo-nuevo-desde-es6-hasta-hoy-parte-1#arrow-functions).**

</Blockquote>

## 3. Pureza - Purity

Si haz seguido los ejemplos hasta ac치 **ya utilizaste function purity y ni cuenta te diste.** Felicidades. Puedes pasar a recoger tu diploma de iniciado en la programaci칩n funcional en tu centro m치s cercano. **Recuerda usar mascarilla.**

> **Una funci칩n pura** es aquella que dados los mismos argumentos da el mismo resultado (SIEMPRE) y que no tiene efectos secundarios.

Viendo el 칰ltimo fragmento de c칩digo, 쯇uedes identificar las funciones puras? Si dijiste todas menos `welcomeUser` felicidades est치s en lo correcto 游봅游봅.

Usualmente se toma la funci칩n de suma `(a, b) => a + b` ya que es el perfecto ejemplo de una funci칩n pura sencilla, pero que sea pura no significa que deba ser sencilla, solo consistente.

Aqu칤 es donde la inmutabilidad cobra peso (al igual que evitar los efectos secundarios) ya que con data mutable es dif칤cil e impredecible crear funciones puras de forma consistente y con seguridad.

Al igual que con los efectos secundarios un programa de solo funciones puras no es nada interesante ya que al no poder crear efectos secundarios ni llamar a funciones que los contengan, limitan lo que podemos hacer. Es por esto que al igual que con los side effects debemos limitarlos a los necesarios, controlarlos y si es posible agruparlos.

### Ventajas de la funciones puras

* Son m치s f치ciles de testear
* Promueven los dem치s pilares de la programaci칩n funcional.
* Nos permiten componer funciones de forma m치s sencilla y eficiente.

## Conclusi칩n

A칰n queda mucho m치s de la programaci칩n funcional que definir y yo estar칠 m치s que encantado de tra칠rtela. Espero que hayas aprendido o se te haya refrescado la memor칤a sobre la programaci칩n funcional.

Si te interesa saber m치s sobre la programaci칩n funcional y a que me refiero con componer funciones 칰nete a lista de correo (**NUEVA**) aqu칤 debajo, donde podr치s enterarte de noticias, cuando suba nuevo contenido al blog o [al podcast](https://www.instagram.com/releaseonfridays/).

Estar칠 compilando contenido interesante y lo enviar칠 por ah칤. **Solo cosas buenas, no SPAM, no vender tu informaci칩n** ~~(a menos que sea por una cantidad tan considerable de dinero que literalmente pueda enviarle un porcentaje a cada uno de ustedes y quedarme con una parte tan grande que me desaparezca por completo del mapa)~~.
