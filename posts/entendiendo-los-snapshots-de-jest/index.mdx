---
title: Entendiendo los snapshots de Jest
date: '2019-12-01'
description: Escribes tests que te den confianza en tu c√≥digo antes de lanzarlo a producci√≥n aprovechando al m√°ximo los snapshots de Jest. Aprende a usarlos de la forma correcta.
author: Misael Taveras
tags: ['Test', 'Tutorial']
status: published
banner: ./media/baner-entendiendo-los-snapshots-de-jest.jpg
---

Jest, creado por Facebook, es un framework de testing para react que trae consigo una herramienta poderosa pero misteriosa; por eso a veces es temida, ignorada o mal usada.

En este post aprenderemos todo de ella, c√≥mo usarla en nuestros tests para probar m√°s con menos y aumentar la confianza en nuestro c√≥digo.

_Si viniste solo por el jugoso tema de los snapshots [da clic ac√°](#snapshots-para-simplificar-los-tests) para saltarte el repaso._

## Repaso r√°pido sobre los tests

> Los tests son c√≥digo que **prueban** c√≥digo.

Lo que hemos desarrollado puede ser de lo mejor y puede funcionar correctamente cuando el usuario lo usa como esperamos, pero ¬øQu√© pasa cuando no? ¬øC√≥mo nos damos cuenta? O incluso nosotros cuando necesitamos refactorizar algo, ¬øC√≥mo nos aseguramos que nuestros cambios no da√±en otras partes? Pues con tests.

<blockquote className="special">

Si est√°s interesado en saber m√°s sobre tests, escr√≠beme en Twitter a [@taverasmisael](https://twitter.com/intent/tweet?via=taverasmisael&text=Quiero%20aprender%20mas%20sobre%20test%20con%20JavaScript) y d√©jame saber.

</blockquote>

Para crear tests necesitamos lo que se conoce como un _Test framework_, una librer√≠a de afirmaciones o _Assertion library_ y si queremos ponernos elegantes, un analizador de cobertura de c√≥digo.

**Test framework:** es el que se encarga de correr nuestras pruebas en un entorno controlado, siguiendo una secuencia y asegur√°ndose de que pasen nuestros asunciones.

**Assertion library:** esta librer√≠a es la que hace las asunciones de nuestro c√≥digo; nos permite crear lineas como `expect(true).toBe(true)` d√°ndonos `matchers` que no son m√°s que funciones que comparan dos valores y lanza un error sin son diferentes. Entre los matchers que trae consigo Jest se encuentran: _toBe, toEqual, toHaveLength y toMatchSnapshot_.

> **Dato interesante**: la consola de javascript tienen una funcionalidad sencilla para esto. Si hacemos `console.assert(expected, "No es lo que esperaba")`la consola imprimir√° como un error `No es lo que esperaba` si expected es false y no har√° nada si es true. Pru√©balo.

[Jest](https://jestjs.io/) es un framework creado por Facebook que a diferencia de sus predecesores es un todo en un con 0 configuraci√≥n para empezar. Incluye el test framework, el assertion library, incluso una herramienta de cobertura; pero m√°s relevante para nosotros ahora, introdujo el concepto de snapshot testing.

## Snapshots, para simplificar los tests

![aaron-schwartz-snap](./media/aaron-schwartz-snap.jpg)

<Caption align="center" footNote="foto-port-aaron-schwartz">

Foto por [Aaron Schwartz](https://www.pexels.com/@aschwaphoto?utm_content=attributionCopyText)

</Caption>

Los tests, como explic√°bamos aseguran que el valor que esperamos sea igual que el que realmente se nos devuelve la funcionalidad que estamos probando. Esto es f√°cil de hacer cuando los valores son simples, como n√∫meros, cadenas, booleanos; pero ¬øQu√© pasa cuando los valores son m√°s complejos? ¬øQu√© hacemos cuando son objetos o queremos asegurarnos que todo nuestro estado sea de una forma? ¬øQu√© tal si queremos asegurar que el componente `X` muestre cierta estructura?

Los snapshots son capturas de un momento o estado especifico en nuestro aplicaci√≥n.

Una forma com√∫n de probar el resultado de un reducer de [Redux](https://redux.js.org/) es haciendo varios checks en los diferentes valores del estado. Tomando de ejemplo que tenemos un simple estado con `isLoading`, `error` y `data`; queremos que al llamar la acci√≥n `DO_REQUEST` se reinic√≠e la `data` a un array vac√≠o, `error` sea una cadena en blanco e `isLoading` sea `true`. El test podr√≠a parecer algo como:

```js
import reducer from './reducer'

// Se usa `describe` para agrupar tests similares
describe('REDUCER', () => {
  // Los bloques `it` representan 1 test y aunque pueden
  // tener varios `expect` es recomendable que sea un solo
  // o que al menos todos los `expects` esten relacionados
  // como es este caso
  it('should set the right state on "DO_REQUEST"', () => {
    const newState = reducer(undefined, { type: 'DO_REQUEST' })
    expect(newState.error).toBe('')
    expect(newState.data).toEqual([])
    expect(newState.isLoading).toBe(true)
  })
})
```

<Caption footNote="repaso-redux">

**Breve repaso de Redux:** La funci√≥n `reducer` toma un estado (en este caso undefined para que use el valor por defecto) y un objeto con un key `type` donde especificamos la operaci√≥n que se va a realizar en dicho estado. La funci√≥n `reducer` entonces devuelve un nuevo estado modificado en base al `type` que especificamos.

</Caption>

Usando este m√©todo no solo tenemos que recordar cada pieza de estado que es relevante para asegurarnos que la funci√≥n haga su trabajo correctamente, sino que tambi√©n, debido a la naturaleza de JavaScript tenemos que usar 2 matchers diferentes, `toBe` y `toEqual`. (_¬øSabes por qu√© tuvimos que usar dos? [Desc√∫brelo aqu√≠](/series/guia-de-javascript/operadores-logicos-aritmeticos-y-de-comparacion#operadores-igualitarios 'Gu√≠a de JavaScript capitulo 4')_).

Ahora veamos el mismo test, con el mismo resultado pero usando snapshots.

```js
import reducer from './reducer'

describe('REDUCER', () => {
  it('should set the right state on "DO_REQUEST"', () => {
    const newState = reducer(undefined, { type: 'DO_REQUEST' })
    // El matcher `toMatchSnapshot` no recibe ningu parametro
    // En la siguiente secci√≥n veremos porqu√© es as√≠
    expect(newState).toMatchSnapshot()
  })
})
```

M√°s simple, m√°s conciso y creo que podemos apreciar el valor que aporta desde ya hasta si tuvi√©ramos un estado m√°s complejo con m√°s que solo 3 keys, o un componente que renderiza una lista, es solo un snapshot y listo.

Veamos los snapshots un poco m√°s en profundidad.

## El ciclo de vida de un snapshot

Cuando creamos los snapshots lo hacemos a trav√©s de un _matcher_ de Jest llamado `toMatchSnapshot` (hay un `toMatchInlineSnapshot` tambi√©n que hace pr√°cticamente lo mismo).

### Usando toMatchSnapshot

Cada vez que corre el test jest verifica que exista un archivo del mismo nombre que el del donde se encuentra el test pero con extensi√≥n **_.snap_** dentro de la carpeta **\_\_snapshots\_\_**: (`reducer.test.js -> __snapshots__/reducer.test.js.snap`)

- La primera vez, como el archivo no est√° Jest lo crear√° y ese ser√° el snapshot con el que se correr√°n nuestros tests.
- Cada vez, despu√©s de la primera vez, que se corra el test Jest esperara que el contenido del archivo `.snap` no haya cambiado. Si el archivo cambia el test falla.
- Si queremos actualizar el snapshot porque hemos cambiado algo y el test est√° fallando tenemos dos opciones:
  1. Pulsar `u` cuando corremos Jest en Watch mode
  2. Correr directamente el comando `jest --updateSnapshot`.

### Usando toMatchInlineSnapshot

Es similar al anterior solo que el snapshot en vez de ser creado, le√≠do y modificado de un archivo jest lo inyecta dentro de la llamada a la funci√≥n `toMatchInlineSnapshot`.

```js
expect(2 + 2).toMatchInlineSnapshot()
// se convierte en...
expect(2 + 2).toMatchInlineSnapshot('4')
```

### Como se ve un archivo .snap

Para nuestro ejemplo de `reducer` el snapshot generado ser√≠a este:

```js
exports[`REDUCER should set the right state on "DO_REQUEST" 1`] = `
Object {
  "data": Array [],
  "error": "",
  "isLoading": true,
}
`
```

<Caption footNote="como-se-ve-un-snap">

_Agrega al export un key con el nombre resultante de la combinaci√≥n del nombre de: **el bloque describe, m√°s el bloque it seguido de un n√∫mero incremental.**_

</Caption>

## Buenas y no tan buenas pr√°cticas para usar snapshots

Durante el tiempo que he usado snapshots para mis tests, he descubierto que no todas las formas de usarlas son beneficiosas y algunas son m√°s provechosas que otras. Aqu√≠ un compilado de las que creo m√°s relevante.

### No uses snapshots para todo

Empecemos por evadir una trampa en la que es f√°cil caer, hacer snapshots de todas las cosas.

![Snapshot all the things](./media/snapshot-all-the-things.jpg)

Si bien es cierto que los snpashots son r√°pidos y ligeros, hacer snapshots de todo puede ‚Äúensuciar‚Äù nuestro repositorio teniendo decenas de archivos con snapshots simples que pudieron ser test ‚Äúcl√°sicos‚Äù.

Otra desventaja de usar snapshots cuando podr√≠amos usar cualquier otro matcher est√° en que los tests dejan de tener sentido sin ver el snapshot, haciendo que a futuros desarrolladores (uno mismo incluido) se le haga dif√≠cil entender la intenci√≥n del test.

```js
// Me invent√© esta librer√≠a üëáüèΩ
import { render, simulate } from 'test-library-for-react'
import Component from './Component'

describe('my obscure test', () => {
  // Este test no a√±ade ningun valor a pesar de que pasa
  //  y probablemente cumpla con el requisito de cobertura de c√≥digo.
  it('should work', () => {
    const component = render(<Component />)
    simulate.click(component.find('button'))
    // ¬°Queeeee! No idea que se supone que hizo el click
    // O como reaccion√≥. Siempre debemos elegir
    // legibilidad por encima de comodidad.
    expect(component).toMatchSnapshot()
  })
})
```

### Los snapshots son excelentes en estructuras complejas

Como vimos en el primer ejemplo, los snapshots pueden garantizar un mejor test cuando se trata de objetos, valores anidados o componentes. Si tienes problemas creando un snapshot de cierta estructura, busca por un paquete de serializaci√≥n, estos son utilidades que hacen que los snapshots tengan m√°s coherencia.
Por ejemplo, si haces tests usando Enzyme, debes instalar el [Enzyme to JSON](https://github.com/adriantoine/enzyme-to-json)) para poder tener snapshots que verdaderamente demuestren la estructura del componente.

### Evita usar snapshots para efectos secundarios

![Andre Mouton Primate](./media/andre-mouton-primate.jpg)

<Caption align="center" footNote="foto-port-aaron-schwartz">

Foto por [Andre Mouton](https://www.pexels.com/@andre-mouton?utm_content=attributionCopyText)

</Caption>

Los efectos secundarios pueden ser impredecibles o suelen pasar fuera del scope de lo que estamos probando. Cosas como eventos, llamadas a APIs, console.logs y dem√°s son considerados como efectos secundarios (no significa necesariamente que sean malos), y si hace uso de ellos es probable que los snapshots no sean la herramienta correcta.

Tomando como ejemplo un evento click que escriba en la consola, es algo que no podemos probar con snapshots porque estos no corren con respecto a la consola.

Para un servicio que llama al API y modifica el resultado para hacerlo m√°s utilizable en la aplicaci√≥n podemos probar el resultado, asegurarnos que el mapeo haya sido correcto o que los par√°metros que enviamos al servidor est√°n bien, pero no podemos hacer snapshot de una _llamada al API_ directamente.

### No hacer snapshots de librer√≠as de terceros

Nuestros tests no deber√≠a nunca hacer pruebas a las librer√≠as de terceros que usamos, eso es trabajo del desarrollador de dicha librer√≠a.

Ahora, en ocasiones nuestro componente (funci√≥n, modulo, etc.) depende de las librer√≠as de terceros. Debemos evitar probar nuestros snapshots contra el c√≥digo de terceros.

En una ocasi√≥n, dur√© unas horas debugueado un snapshot que siempre daba diferencias sin importar qu√©. Cuando pude descubrir que pasaba, una librer√≠a de gr√°ficos al generar la gr√°fica agregaba un _hash_ al ID del container, as√≠ que cada que corr√≠a el test el ID era diferente. Lo que hice fue ignorar lo que renderizaba esa librer√≠a y lo sustitu√≠ por un placeholder `Chart` ya que no era responsabilidad de ese test saber COMO se estaba renderizando el gr√°fico.

## Qu√© son y qu√© no son los snpashots

- Los snapshots **son** una herramienta √∫til para asegurarnos de que nuestros resultados no cambien de forma inesperada.
- Los snapshots **son** una forma r√°pida de probar UIs o valores complejos.
- Los snapshots **son** parte de nuestra aplicaci√≥n por lo que DEBEN ser comiteados tambi√©n.
- Los snapshots **son** validos para en la cobertura de c√≥digo.
- Los snapshots **no son** un reemplazo para nuestros tests unitarios.
- Los snapshots **no son** lentos de generar/validar. Jest usa algo parecido al `diff` de Git para agilizar este proceso.
- Los snapshots **no son** buenos para hacer TDD y a que los snapshots est√°n pensados con el un estado final en mente, as√≠ que habr√≠a que estar actualizando los snapshots en cada cambio.

## Conclusi√≥n

En este articulo hemos explorado una de las herramientas que tenemos a la mano para crear tests con m√°s facilidad. **Si eliminamos la fricci√≥n que existe para empezar a crear test, es m√°s probable que empecemos a hacerlos.** Ya no hay excusas para no agregar tests a tus aplicaciones.

Si te ha gustado el tema y te ha ayudado, **comp√°rtelo con alguien a quien podr√≠a interesarle**. Esto no solo ayudar√≠a a la persona con quien lo compartas, sino que tambi√©n me ayuda a m√≠ a saber que este es un contenido de inter√©s.

Como mencion√© arriba, si tienes m√°s inter√©s sobre hacer tests en JavaScripts d√©jame saber en [Twitter](https://twitter.com/taverasmisael) que tema te gustar√≠a que yo hablara luego y estar√© haciendo lo posible por traer ese tema.
