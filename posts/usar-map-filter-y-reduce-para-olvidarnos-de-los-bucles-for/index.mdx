---
title: Usar map, filter y reduce para olvidarnos de los bucles for
date: '2019-08-18'
description: Aprendiendo a usar las funciones map, filte y reduce para mejorar nuestras habilidades como desarrollador.
author: Misael Taveras
tags: ['Tutorial', 'JavaScript', 'Programaci√≥n Funcional']
status: published
banner: ./media/banner.jpg
---

Hoy quiero mostrarte como recorrer un array sin usar un bucle. En lo personal nunca me han gustado los
bucles for, en ning√∫n lenguaje. Su sintaxis es tan diferente a lo dem√°s del c√≥digo, es bastante imperativo
entre otras cosas.

Un bucle es una secuencia de c√≥digo que se repite un determinado n√∫mero de veces hasta que la condici√≥n
se completa. Normalmente son utilizados para recorrer arreglos, transformar objetos dentro de arreglos,
filtrar elementos o calcular alg√∫n resultado basado en dichos elementos. Algunas de las estructuras m√°s
usadas en la programaci√≥n para lograr esto son el _while_, _until_ y _for_. Nos centraremos en el for.

En Javascript hay 3 diferentes bucles for que podemos utilizar. Cada uno con nos da diferentes
capacidades y puede ser usado en diferentes escenarios. Est√°n el for, for...in, for...of.
Hablaremos en espec√≠fico del **bucle for** y como podemos reemplazarlo con _map, filter y reduce_.

> La diferencia entre el `for...in` y el `for...of` la trataremos m√°s adelante
> ya que se sale del enfoque del post.

## Bucle For

Es una de las estructuras de control mas complejas y √∫tiles que existe. Es el primero que se aprende
y tiene una sintaxis as√≠:

`for ([expresi√≥n-inicial]; [condici√≥n]; [expresi√≥n-final])sentencia`

La expresi√≥n es una declaraci√≥n del punto de partida, la condici√≥n es la que debe cumplirse para que
el bucle se termine y la expresi√≥n final suele ser un incrementador de nuestro punto de partida.

<Caption>Como filtrar solo los n√∫meros impares usando un bucle for</Caption>

```js
const numberArray = [1, 2, 3, 4, 5, 6]
let impares = []
for (let i = 0; i <= numberArray.length - 1; i += 1) {
  if (numberArray[i] % 2 !== 0) {
    impares.push(numberArray[i])
  }
}
```

<Caption>Como convertir palabras a mayuscula usando un bucle for</Caption>

```js
const words = ['pera', 'lapiz', 'mesa']
let mayusc = []
for (let i = 0; i <= words.length - 1; i += 1) {
  mayusc.push(words[i].toUpperCase())
}
```

<Caption>Calcular total de ventas de una pizzer√≠a usando un bucle for</Caption>

```js
const orders = [
  { product: 'Pizza al carbon', total: 3, date: '2019-08-12' },
  { product: 'Pizza de queso', total: 10, date: '2019-08-12' },
  { product: 'Pizza de 3 ingredientes', total: 5, date: '2019-08-12' },
  { product: 'Especial del chef', total: 30, date: '2019-08-12' },
  { product: 'Especial del chef', total: 3, date: '2019-08-13' },
  { product: 'Pizza al carbon', total: 10, date: '2019-08-14' },
]
let totals = {}
for (let i = 0; i <= orders.length - 1; i += 1) {
  const order = orders[i]
  const product = order.product
  const total = order.total
  totals = Object.assign({}, totals, {
    [product]: (totals[product] || 0) + total,
  })
}
```

### Problemas con el bucle for

1. **Es demasiado imperativo.** Tenemos que decirle al programa cual es el array, desde donde queremos
   leerlo (que casi siempre es desde el inicio), hasta que punto ya no queremos seguir, como aumentar el √≠ndice
   cada vez que leemos y solo luego lo que realmente queriamos que era filtrar los n√∫meros impares. Deber√≠a
   haber un modo de solo decirle al programa esta √∫ltima parte, lo que yo realmente quiero hacer y no tanto
   el c√≥mo (eso es programaci√≥n declarativa).
2. **No se ve la intenci√≥n.** Cada programa que hacemos debe ser intencional y dicha intenci√≥n debe
   ser clara cuanto antes. Por ello es mejor tener la l√≥gica compartida junta, y otras practicas que un
   bucle for hace dif√≠cil de cumplir. Lo primero que ves es toda la ceremonia de iterar y luego es que
   ves que es lo que realmente intenta hacer tu programa. En el ejemplo de
   [calcular las ventas](#caption-calcular-total-de-ventas-de-una-pizzeria-usando-un-bucle-for) es m√°s
   evidente este punto.
3. **No es reusable.** La √∫nica manera de volver a filtrar los n√∫meros impares de otro array es
   copiando y pegando este c√≥digo, no hay una forma de encapsularlo. Claro, puedes tener una funci√≥n
   que acepte un array y haga esto por mi, pero no es nada elegante y hay mejores formas de hacer esto.
4. **El error por uno.** Hay que tener en cuenta que nosotros hacemos la l√≥gica de cuando detener
   el bucle y de donde iniciarlo. Con un cambio tan sencillo como `let i = 1` omitimos el primer
   elemento o con `i <= numberArray.length` tenemos un elemento de m√°s que da undefined.
   Dos escenarios que es mejor evitar en la medida de lo posible.
5. **Son mutables.** Aunque en ning√∫no de los ejemplos lo hicimos es completamente posible
   modificar un valor del array inicial lo cual puede traernos feas consecuencias en el camino.
6. **Es mucho c√≥digo** admit√°moslo, a decir verdad se siente mucho trabajo para hacer algo tan simple.

Veamos ahora mejores formas de como podemos filtrar, convertir y calcular nuestros arrays usando
filter, map y reduce.

## Filter

Es un m√©todo que acepta una funci√≥n que devuelve true o false indicando si nos interesa el
elemento o no. Estas funciones que toman un objeto y devuelven un valor Boolean se
llaman **Funciones predicado**.

<Caption>
  Como filtrar solo los n√∫meros impares usando la funci√≥n filter
</Caption>

```js
const numberArray = [1, 2, 3, 4, 5, 6]
/* Con funciones tradicionales 
const impares = numberArray.filter(function(n) {
  return n % 2 !== 0
})
*/

/* Con arrow functions. Estar√© usando esta sintaxis de ahora en adelante */
const timpares = numberArray.filter(n => n % 2 !== 0)
```

<Caption align="center" footNote="funciones-flehca">

Visita mi post donde explico con [m√°s detalles las arrow functions](/blog/javascript-todo-lo-nuevo-desde-es6-hasta-hoy-parte-1#arrow-functions).

</Caption>

Listo ya est√°. La funci√≥n filter se encarga de iterar por s√≠ sola iniciando en 0 y
terminando en `length - 1` as√≠ que no hay error por 1, y nos devuelve en el primer par√°metro el
elemento actual (equivalente a `numberArray[i]`). Es m√°s f√°cil de entender que a simple vista qu√©
est√° haciendo que con el bucle for.

## Map

Al igual que filter, map es un m√©todo en los arrays que acepta una funci√≥n, solo que esta es una
funci√≥n transformadora que toma un elemento `a` y devuelve un elemento `b`.

Querremos usar `map` cuando tengamos un array de elementos que deba ser transformado. A diferencia
de filter, **map siempre retorna la misma cantidad de elementos del array inicial** independientemente
de la transformaci√≥n que apliquemos. Es posible tambi√©n no modificar ning√∫n elemento utilizando una
**funci√≥n de identidad** que no es m√°s que una funci√≥n que siempre devuelve su par√°metro como resultado,
as√≠ en vez de `a=>b` tenemos `a=>a`.

> Es bueno saber que tanto `map` como `filter` y `reduce` son m√©todos imutables y nunca
> modifican el array que los llama, sino que devuelven una nueva copia que debe ser almacenada
> en otra variable.

<Caption>Como convertir palabras a mayuscula usando la funci√≥n map</Caption>

```js
const words = ['pera', 'lapiz', 'mesa']
const mayusc = words.map(word => word.toUpperCase())
```

No podr√≠a ser m√°s simple que esto. A map le pasamos una funci√≥n que recibe los elementos y esta
devuelve los elementos transformados sin afectar el array original. Lo que eran varias l√≠neas de
c√≥digo, mayormente de _boilerplate_ se convirti√≥ en una sola l√≠nea.

## Reduce

Estas ya son las _‚ÄùLigas mayores‚Äù_. La funci√≥n reduce es la m√°s compleja de las tres, por eso es la
m√°s poderosa. Aun as√≠, sigue siendo m√°s f√°cil e intuitiva que un bucle for, y cumple con las mismas
caracter√≠sticas que las anteriores, as√≠ que veamos que nos ofrece la funci√≥n reduce.

Al igual que sus hermanas, es una funci√≥n de los arrays que recibe otra funci√≥n, pero en esta ocasi√≥n
en vez de aceptar solo el elemento actual, el primer par√°metro de esta es el valor anterior ü§Ø.
Por **valor anterior** me refiero al resultado o lo que devolvi√≥ la funci√≥n la √∫ltima vez que se llam√≥.
Veamos un ejemplo sencillo.

<Caption>Sumando total de n√∫meros con el m√©todo reduce</Caption>

```js
const numbers = [1, 2, 3, 4, 5]
const total = numbers.reduce((previous, number) => previous + number)
```

Siempre `number` va a ser el valor actual (equivalente a `numbers[i]`) y `previous` va a ser el
resultado de la √∫ltima vez que se llam√≥ la funci√≥n. Pero ¬øQu√© pasa la primera vez que se llama la
funci√≥n? ¬øQui√©n es `previous` ah√≠? Pues por defecto se utiliza el primer elemento del array y este se
omite; pero si deseamos podemos proporcionar nuestro propio valor inicial pasando un segundo par√°metro
opcional a la funci√≥n de reduce.

<Caption>
  Sumando total de n√∫meros usando un valor inicial con el m√©todo reduce
</Caption>

```js
const prices = [1, 2, 3, 4, 5]
const initial = 10
const total = prices.reduce((previous, number) => previous + number, initial)
```

En este ejemplo `previous` la primera vez ser√° igual al valor de `initial` que es 10 en este caso.
as√≠ la primera vez que corre en lugar de devolver 1, devuelve 11 y de ah√≠ sigue todo como antes.

Veamos ahora nuestro ejemplo anterior de sumar totales, agrupando o _reduciendo_ todos los totales.

<Caption>Sumando total ordenes con el m√©todo reduce</Caption>

```js
const orders = [
  { product: 'Pizza al carbon', total: 3, date: '2019-08-12' },
  { product: 'Pizza de queso', total: 10, date: '2019-08-12' },
  { product: 'Pizza de 3 ingredientes', total: 5, date: '2019-08-12' },
  { product: 'Especial del chef', total: 30, date: '2019-08-12' },
  { product: 'Especial del chef', total: 3, date: '2019-08-13' },
  { product: 'Pizza al carbon', total: 10, date: '2019-08-14' },
]

const totals = orders.reduce(
  (previous, order) =>
    Object.assign({}, previous, {
      [order.product]: (previous[order.product] || 0) + order.total,
    }),
  {}
)
```

En este ejemplo usamos como valor inicial un objeto vac√≠o, de este modo podemos agrupar todas las
partes como keys de dicho objeto. **El valor incial usualmente representa el tipo de dato que deseamos devolver**.
En los primeros ejemplos usamos como valor inicial un n√∫mero y por ende devolvimos un n√∫mero.

## Reusando la l√≥gica

Utilizando el poder de JavaScript de permitirnos usar funciones como variables y pasarlas como
argumentos a otras funciones podemos extraer cada una de estas y reutilizarlas cuando sea posible.
Usar√© el ejemplo con `filter` pero es aplicable a las dem√°s.

<Caption>Reusando la funci√≥n filter</Caption>

```js
const filterOdd = n => n % 2 !== 0
const arrayOne = [1, 2, 3, 4, 5]
const arrayTwo = [11, 22, 33, 44, 55]
const arrayOneOdds = arrayOne.filter(filterOdd)
const arrayTwoOdds = arrayTwo.filter(filterOdd)
```

As√≠ de simple podemos llevar nuestras funciones a cualquier parte de forma sencilla y descriptiva,
m√°s que un bucle for.

## Bonus 1: Usando librer√≠as

Si estamos utilizando una librer√≠a de utilidades o funcional como
[ramda](https://ramdajs.com) o [lodash](https://lodash.com/docs) estas cuentan con sus propias
funciones filter, map y reduce que nos ayudan a extender la reusabilidad.

<Caption>Ejemplo de map usando ramda</Caption>

```js
// Asumiendo que hayas instalado ramda
import { map } from 'ramda'
const addTen = number => number + 10
const mapAddTen = map(addTen)

const arrayOne = [1, 2, 3, 4, 5]
const arrayTwo = [11, 22, 33, 44, 55]

const arrayOnePlusTen = mapAddTen(arrayOne)
const arrayTwoPlusTen = mapAddTen(arrayTwo)
```

## Bonus 2: Encontrar un √∫nico elemento

En ocaciones no queremos filtrar **TODOS** los elementos que cumplan cierta condici√≥n sino que
queremos encontrar un √∫nico elemento, para esto existe otro m√©todo en los arrays que al igual
que [`filter`](#filter) acepta una funci√≥n de predicado pero esta, a diferencia de la anterior, deja de
recorrer el array desde que encuentra el primer elemento que cumple la condici√≥n.

### Find

<Caption>Ejemplo usando el m√©todo find</Caption>

```js
const friends = [
  { name: 'Maria', points: 2 },
  { name: 'Daniel', points: 5 },
  { name: 'Giancarlos', points: 4 },
  { name: 'Efrain', points: 2 },
]

// Devuelve el primer amigo con 4 puntos
const friendWithMorePointsThanFour = friends.find(friend => friend.points > 4)
```

Cabe mencionar que a diferencia de `filter`, `find` va a devolver `null` en caso de que ning√∫n
elemento pase el predicado, mientras que **_filter_ siempre va a devolver un array incluso vac√≠o.**

## Conclusi√≥n

Espero que estos m√©todos te hayan servido y puedas implementarlos en tus futuros desarrollos.
Te invito a que empieces a utilizarlos hoy mismo. Planeo hacer otro post con ejemplos m√°s avanzados
de cada uno de estos m√©todos en detalle. Si alguno te sirvi√≥, te gust√≥ o no te qued√≥ claro
[**escr√≠beme**](https://twitter.com/taverasmisael).

Todo los ejemplos (con el bucle y los metodos) estan en este Sandbox.

<SourceButtons demoURL="https://codesandbox.io/s/map-filter-y-reduce-para-no-usar-un-bucle-for-tdk5g?fontsize=14&previewwindow=tests" />
