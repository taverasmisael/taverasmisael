---
title: Lo nuevo que trae ES2020
date: '2020-08-10'
description: Son 10 consejos que yo he aprendido a lo largo de mi corta vida pero que me falta ponerlas en pr√°ctica y que creo que podr√≠an beneficiarte tambi√©n y as√≠ me sirven a mi tambi√©n de recordatorio.
author: Misael Taveras
tags: ['JavaScript', 'ES6']
status: published
banner: './media/banner-lo-que-trae-es2020.jpg'
---

En este blog amamos JavaScript y es por eso que he dedicado toda una miniserie a los features que han sido introducidos desde ES6 en adelante.

![./media/amamos-javascript.png](./media/amamos-javascript.png)

El d√≠a de hoy es hora de hablar sobre las nuevas caracter√≠sticas del lenguaje adoptadas en este a√±o. Algunas son interesantes, asombrosas, otras son balances peque√±os pero que se aprecian.

Veamos esta lista, mezclando entre m√°s y menos interesantes.

<Blockquote type="disclaimer">

  El tema de hoy fue recomendado por un suscriptor de la [newsletter](#newsletter).

</Blockquote>

## BigInt

JavaScript y los n√∫meros no se llevan bien. Por eso hay tantas librer√≠as que se encargan de hacer las matem√°ticas pesadas en JavaScript. Los BigInts pretenden solucionar esto.

El l√≠mite te√≥rico de los valores enteros en JavaScript es `9007199254740991` (obtenido con `Number.MAX_SAFE_INTEGER`)  cualquier n√∫mero que sumemos o restemos de aqu√≠ es tan confiable como las promesas de tu ex. Aqu√≠ es donde entra el nuevo tipo de dato BigInt. 

Agregando una `n` al final de nuestros valores enteros los convertimos de Int a BigInt.

```js
const int = 9007199254740992
const bigint = 9007199254740992n // Mismo n√∫mero pero convertido en BigInt
console.log(int === int + 1) // true üò≥
console.log(bigint === bigint + 1n) // false üòå
```

## Dynamic Imports

Bueno, esto ha estado hace un tiempo ya, gracias a Babel y webpack (y el hermoso parcel), pero ahora es algo oficial en el lenguaje que podremos ver a los navegadores (que a√∫n no lo tienen) implementando en el futuro cercano.

Sin rodeos y para quien no conoc√≠a lo de importar m√≥dulos de forma din√°mica, **es una forma de importar los m√≥dulos que queremos solo en las situaciones que los necesitamos.** En un ejemplo (s√∫per hipot√©tico) de una calculadora s√∫per cient√≠fica en la que mayormente solo se hacen divisiones y no sumas, podr√≠amos, gracias a los dynamic imports, tener algo como esto.

```js
import divide from './operations/division' // Se importa siempre

async function Calculate(a, b, op) {
  // ... Cosas cient√≠ficas
  if (op === 'sum') {
    const sum = await import('./operations/sum') // Se importa solo cuando se hace suma
    sum(a, b)
  }
}
```

<Blockquote type="info">

  **¬øEsto no importar√≠a el m√≥dulo cada vez que sumemos?** Buena pregunta, pero la respuesta es no. Primero se revisa si el m√≥dulo ya se hab√≠a importado antes, de ser as√≠ se utiliza el que est√° en cach√© y as√≠ no se hacen m√∫ltiples peticiones a la red. La forma de saber si el m√≥dulo ya ha sido importado o no es a trav√©s de la metadata del m√≥dulo.

</Blockquote>

## Module metadata

~~Me quedar√© con la versi√≥n en ingl√©s de los nombres ya que traducir algo que vamos a usar siempre en ingl√©s no vale la pena.~~

Directo al punto. Ahora los m√≥dulos al importarlos exponen un key `meta` que hab√≠a estado vac√≠o antes. Ahora contienen informaci√≥n como la `url` del archivo que tiene el m√≥dulo entre otras cosas.

## Module namespace export

Para cerrar el apartado sobre los m√≥dulos tenemos este otro peque√±o pero muy apreciado. Y es que JavaScript **nos permit√≠a importar todo el contenido de un m√≥dulo usando el asterisco (*) y asign√°ndole un nombre**, pero no pod√≠amos hacer lo mismo para exportarlo; deb√≠amos exportar directamente parte por parte o agregar un `export object` especificando lo que se exportaba. Ahora podemos hacer lo siguiente:

```js
// Lo que siempre hemos podido hacer
import * as operations from './operations'

// Como se deb√≠a exportar antes
import * as sum from './sum'
export { sum }

// Como se puede exportar ahora
export * as sum from './sum'
```

## Nullish Coalescing

Este es una de mis caracter√≠sticas favoritas y m√°s esperadas de esta iteraci√≥n de JavaScript. El nuevo operador de doble interrogaci√≥n `??` nos permite verificar que el valor a la izquierda es realmente `null || undefined` en lugar de verificar si es un valor `falsy` .

> En JavaScript los valores `falsy` son aquellos que el lenguaje trata como `false` aunque no lo sean. Esto incluyen u*n string vac√≠o, el n√∫mero 0, null, undefined, NaN y por supuesto el booleano false.*

Veamos un ejemplo de como esto nos puede ayudar a simplificar nuestro c√≥digo en ciertos escenarios.

```js
const showValue = (val) => console.log(`El valor es ${val || 'NO VALOR'}`)

// El valor es NO VALOR
showValue()
showValue(0)
showValue(false)
showValue('')
showValue(NaN)

// El siguiente c√≥digo si funciona, pero el syntax highlighter todav√≠a no conoce esta sintaxis.

const showValueIfNotNull = (val) => console.log(`El valor es ${val ?? 'NO VALOR'}`)

// Una forma de hacer esto antes era
const oldShowValueIfNotNull = (val) => {
  // Revisar explicitamente por valores null o undefined
  const value = val === null || val === undefined ? 'NO VALOR' : val
  console.log(`El valor es ${value}`)
}

showValueIfNotNull() // El valor es NO VALOR
showValueIfNotNull(0) // El valor es 0
showValueIfNotNull(false) // El valor es NO false
showValueIfNotNull('') // El valor es
showValueIfNotNull(NaN) // El valor es NaN

```

## Promise.allSettled

Las promesas han venido para quedarse. Y es que son la mejor forma de crear c√≥digo as√≠ncrono en JavaScript.

A√∫n as√≠, cuando empezamos a implementarlas solo pod√≠amos hacerlo de una a la vez y hab√≠a que hacer magia si quer√≠amos ejecutar alguna funci√≥n independientemente de como se resolviera la funci√≥n. Para correr una funci√≥n cuando termine la promesa, independientemente del resultado, tenemos el m√©todo `Promise.finally`.

Para ejecutar varias promesas a la vez hay varios m√©todos: `Promise.race` `Promise.all` y ahora `Promise.allSettled` que a diferencia de Promise.all, que se completa cuando **todas se completan y falla si al menos una falla,** este se completa cuando todas **terminan** independientemente si fallaron o no.

```js
const promises = [
  Promise.reject(100),
  Promise.resolve('Juanito'),
  Promise.reject(new Error('E')),
]

Promise.allSettled(promises).then(r => {
  console.log(r.map((p) => p.status)) // ['rejected'', 'fullfilled', 'rejected']
})

// Comparada con Promise.all
Promise.all(promises)
  .then(_ => {/* Esto nunca se llama */})
  .catch(e => console.log(e)) // 100 -> al primer reject se detiene
```

## Optional Chaining

Este, de mis favoritos tambi√©n y lo llegu√© a mencionar en el post de [ES6 y m√°s all√° parte 2](/blog/javascript-todo-lo-nuevo-desde-es6-hasta-hoy-parte-2#optional-chaining) (en la parte de m√°s all√°). **Di adi√≥s a las pir√°mides de c√≥digo con un mont√≥n de ifs anidados para verificar si una propiedad existe.** Con el optional chaining operator (`.?`) puedes acceder a propiedades anidadas sin preocuparte por errores.

![./media/Untitled.png](./media/virgin-vs-chad.png)

```js
// The virgin property check
if(user && user.profile && user.profile.personalInfo && user.personalInfo.name) {
  console.log(user.profile.personalInfo.name)
}

// The Chad property check
console.log(user?.profile?.personalInfo?.name) //`undefined` o el nombre del usuario
```

## Regexp y otras cosas

En este apartado incluyo otros cambios que vienen en ES2020 pero que no son tan vistosos (al menos para mi) pero que siguen siendo buenos.

- **String#matchAll**: para expresiones regulares sobre los strings.
- **globalThis**: del que ya habl√© [aqu√≠](/blog/javascript-todo-lo-nuevo-desde-es6-hasta-hoy-parte-2#otras-cosas-para-el-futuro-de-javascript).
- **Estandarizaci√≥n** en el orden que `for in` funciona. Si quieres saber m√°s sobre los bucles for, aqu√≠ te dejo [un post donde explico todo.](/blog/domina-todos-los-bucles-for-en-que-hay-en-java-script)
- **M√©todos privados en clases**: De los que hablo [ac√°](/blog/javascript-todo-lo-nuevo-desde-es6-hasta-hoy-parte-2#metodos-estaticos-y-valores-privados-en-clases).

## Conclusi√≥n

El lenguaje de JavaScript avanza y evoluciona. Es bonito ver que ya no estamos viviendo como en los tiempos de antes en los que **dur√°bamos casi 10 a√±os para que se agregaran cosas** al lenguaje y se estandarizaran otras.

Ahora no solo se est√°n agregando nuevos elementos y mejorando los anteriores, sino que tambi√©n las plataformas como node y los [navegadores (todos ellos)](https://open.spotify.com/episode/0gq4CLCRwVUuwTXjmIHraM) est√°n adoptando r√°pidamente estas caracter√≠sticas **desplazando cada vez m√°s la necesidad de usar transpilers**. El futuro es prometedor.

Por favor, d√©jame saber **cu√°l de estas es tu caracter√≠stica favorita de ES2020**. Si quieres no perderte nada y sugerir temas como el de hoy, te recomiendo que te suscribas a mi [newsletter](#newsletter), es gratis y est√° llena de informaci√≥n no intrusiva relevante.
